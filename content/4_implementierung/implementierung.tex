%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Titel:   Implementierung
% Autor:   zursr1, gross10
% Datum:   28.05.2014
% Version: 0.0.1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%:::Change-Log:::
% Versionierung erfolgt auf folgende Gegebenheiten: -1. Release Versionen
%                                                   -2. Neue Kapitel
%                                                   -3. Fehlerkorrekturen
%
% 0.0.0       Erstellung der Datei
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementierung}\label{ch:implementierung}\todo{myRIO, FPGA erwähnen / erläutern}
%
%
% Analyse Portierung MATLAB 
\section{Analyse Portierung MATLAB}\label{s:analyse_portierung_matlab}\todo{Keine Umsetzung, nur Design und VIs!}
	Für die Implementierung des im vorherigen Kapitels \vref{ch:konzept} konzeptionierten Algorithmus muss das erstellte \gls{g:matlab}-Skript analysiert werden. Es gilt \gls{ac:vi}s zu finden, die möglichst die gleiche Funktion haben wie die verwendeten Befehle und Toolboxen in \gls{g:matlab}. Dabei wird auf das Verwenden von \gls{g:matlab}-Skripten innerhalb von \gls{g:labview} verzichtet um die Eigenständigkeit der Implementierung zu gewährleisten\footnote{Mit der \gls{g:matlab}-Node ist es möglich \gls{g:matlab}-Code auszuführen, jedoch nicht auf einem Real-Time System wie das \gls{g:myrio} eines ist. Ausserdem muss für das Ausführen lokal \gls{g:matlab} installiert sein \cite{lit:labview_matlab}}. Weiter soll eine Struktur gefunden werden, die den Ablauf des \gls{g:matlab}-Skripts widerspiegelt.
	%
	\subsection{Struktur}\label{ss:struktur}
		Betrachtet man die Abbildung \vref{img:blockdiagramm} im Abschnitt \ref{s:blockdiagramm}, so sind zwei Bereiche offensichtlich. Der erste Teil beinhaltet das Schätzen der Rotationswinkel mit Hilfe der Gravität und das anschliessende berechnen der Rotationsmatrix. Darauf folgt das Anwenden der Rotationsmatrix auf die gemessenen Daten und das Integrieren, was der zweite Teil des Konzepts darstellt. Die beiden Teile lassen sich in ein Zustandsdiagramm transformieren, der es erlaubt die Implementierung zu strukturieren. Das Diagramm ist dargestellt in der Abbildung \vref{img:statediagramm}. \gls{g:labview} bietet einige Möglichkeiten den Datenfluss durch Strukturen zu beeinflussen. Für eine Zustandsmaschine bietet sich die Case Structure an, die äquivalent zu dem Konstrukt switch-case der Programmiersprache C funktioniert. 
		%
		\image{content/4_implementierung/image/zustandsdiagramm}{scale=.8}{htbp}[Zustandswechsel][img:statediagramm]
		%
		\subsubsection*{Initialisierungs-Zustand}
			Der erste Zustand stellt die Initialisierung dar. Er wird aufgerufen wenn der Taster am \gls{g:myrio} gedrückt wird. Wie im Konzept vorgesehen werden die Rotationswinkel geschätzt und die Rotationsmatrix bestimmt. Dies geschieht über eine einstellbare Anzahl von Samples. Anzumerken ist, dass während der Aufzeichnung dieser Samples das \gls{g:myrio} nicht berührt werden darf\footnote{Verfälscht die Schätzung der Winkel, was eine inkorrekte Matrix zur Folge hat.}. Im Unterschied zum Konzept wird ausserdem die Standardabweichung der aufgezeichneten Daten bestimmt. Diese wird im Zustand Signalverarbeitung für die Bewegungsdetektion verwendet\footnote{Im Konzept wird dies während der Signalverarbeitung durchgeführt, da Segment basierend.}. 
		%
		\subsubsection*{Signalverarbeitungs-Zustand}
			Im zweiten Zustand erfolgt wie vorgesehen die Signalverarbeitung bestehend aus den Teilen Rotieren, Bewegungsdetektion und Integrieren. Für korrekte Ergebnisse muss zuvor eine Initialisation durchgeführt worden sein. Im Gegensatz zum Konzept und dem vorherigen Zustand erfolgt die Verarbeitung Sample basierend. So kann eine schnelle Laufzeit und ein geringerer Speicherverbrauch forciert, jedoch nicht garantiert werden. Zusätzlich zum Konzept muss noch eine Möglichkeit bestehen die verarbeiteten Daten aus dem Target zu extrahieren. Dazu muss, wie in Abschnitt \vref{ss:myRIO_hw} beschrieben, ein Netzwerkstream zum Host aufgebaut werden. 
	%
	\subsection{Tiefpass-Filterung}
		\gls{g:labview} bietet eine Vielzahl von Möglichkeiten Filter einzusetzen. Sie unterscheiden sich hauptsächlich durch ihre Charakteristik und Implementierung. Bezüglich der Umsetzung existieren Segment und Sample basierte \gls{ac:vi}s. Da die Signalverarbeitung mit Samples arbeitet, kann ein Tiefpassfilter der \texttt{NI\_PtByPt} Bibliothek eingesetzt werden\footnote{\gls{ac:vi} Bezeichnung \texttt{Butterworth Filter PtByPt.vi}}. Die Charakteristik ist wie im Konzept Butterworth (\acrshort{ac:iir}-Filter).
	%
	\subsection{Schätzung der Orientierung}
		Die Schätzung der Orientierung erfolgt analog zum Konzept. Dazu muss eine eigene \gls{ac:vi} basierend auf bestehenden erstellt werden. Die Implementierung ist im Abschnitt \vref{ss:demo_target} erklärt.
	%
	\subsection{Rotation}
		Wie zuvor die Schätzung der Orientierung existiert keine vorgefertigte \gls{ac:vi} für diese Aufgabe. Die Implementierung muss mit Hilfe von bestehenden Komponenten erfolgen, wobei sich diese auf mathematische Operationen beschränken.
	%
	\subsection{Bewegungsdetektion}
		Wie im Abschnitt \vref{ss:struktur} abgetönt erfolgt die Bewegungsdetektion in zwei Schritten. Im ersten werden die Schwellen für eine ruhende Position des \gls{g:myrio} ermittelt. Diese dienen bei der Signalverarbeitung als Vergleichswert, was das Erkennen ein Bewegung ermöglicht. Begründet durch diese Aufteilung kann dieser Vorgang nicht einem einzelnen \gls{ac:vi} erfolgen, sondern muss durch einzelne vorhandene Komponenten umgesetzt werden.	
	%
	\subsection{Integration}
		Für die zweifache Integration werden \acrshort{ac:iir}-Filter eingesetzt die durch eine bilineare Transformation eines Integrators bestimmt wurden. \gls{g:labview} bietet eine \gls{ac:vi} Namens \texttt{IIR Cascade Filter PtByPt.vi}, die es erlaubt direkt die Filterkoeffizienten anzugeben. Die Implementierung ist dabei wie in Gleichung \vref{eq:irr_filter} dargestellt. Zu beachten ist, dass die Koeffizienten nicht vertauscht werden, da die Angabe in der Reihenfolge Nenner $a_x$ Zähler $b_x$ erfolgt.
		%
		\formula{
		H(z)=\frac{b_0+b_1\cdot z^{-1}+\cdots+b_{N_b-1}\cdot z^{-(N_b-1)}}{1+a_1\cdot z^{-1}+\cdots+a_{N_a-1}\cdot z^{-(N_a-1)}}
		}{
		b_x & Forward Koeffizienten\\
		a_x & Reverse Koeffizienten\\
		N_b & Anzahl Forward Koeffizienten\\
		N_a & Anzahl Reverse Koeffizienten\\
		}[eq:irr_filter]
%
%
% Demonstrator
\section{Demonstrator}\label{s:demonstrator}
	Der Demonstrator stellt die Umsetzung des zuvor analysierten \gls{g:matlab}-Skripts dar. Er dient hauptsächlich zur Demonstration des entwickelten Algorithmus, soll aber auch dessen Funktionalität auf einer embedded Hardware zeigen. Die Implementierung basiert auf dem Beispielprojekt \textsf{Posture Estimation} von \gls{ac:ni}, das der Installation von \gls{g:labview} beiliegt. Die Daten der folgend beschriebenen Umsetzung (Projekt \texttt{reametric}) sind im Anhang \vref{s:anhang_labview} zu finden.\par 
	%
	%
	\subsection{Target}\label{ss:demo_target}
		Das \gls{g:labview}-Projekt ist in zwei Teile gegliedert. Der eine beinhaltet \gls{ac:vi}s die auf dem Target ausgeführt werden und der andere diejenigen des Hosts. Dieser Umstand ist im Abschnitt \vref{ss:aufbau_struktur} näher erläutert. Für die Ausführung auf seitens des Targets werden die erstellten \gls{ac:vi}s einem Kompilationsprozess unterzogen, der für das Target ausführbaren Code erzeugt. Im Falle des \gls{g:myrio} wird dies Code für die beiden ARM-Cores und das FPGA sein. Diese Aussage kann jedoch mangels Transparenz des Prozesses nicht bewiesen werden ist nur eine Annahme.
		%
		\subsubsection*{Zustandsmaschine}
			Die Zustandsmaschine wird mit Hilfe einer Case Structure umgesetzt, wie bereits im Abschnitt XXX angetönt. Für den Wechsel zwischen den beiden Vorhanden Zuständen dient ein Taster als Auslöser eines entsprechenden Events. Um die Bedienung komfortabel zu gestalten kann auf zwei Möglichkeiten eine Initialisierung ausgelöst werden.
			%
			\begin{itemize}
				\item \textbf{Hardware Taster} Für die eine Reinitialisierung direkt beim Messaufbau kann der Taster Button am Gehäuse des \gls{g:myrio} betätigt werden.
				\item \textbf{Software Taster} Erfolgt die Bedienung von Messaufbau entfernt via des Host, so bietet die \textit{RT Main}-\gls{ac:vi} einen entsprechenden Taster.
			\end{itemize}
			%
			Implementiert diese Funktion zum einen mit einer speziellen \gls{ac:vi} des \gls{g:myrio} für das Abfragen des Tasters und zum anderen mit einer \gls{ac:vi} für die Flankenerkennung. Der Software Taster wird mit diesem Aufbau durch ein ODER-Gatter verknüpft. Die Abbildung \vref{img:state_switch} zeigt das gesamte Konstrukt.
			%
			\image{content/4_implementierung/image/button}{scale=.7}{htbp}[Zustandswechsel][img:state_switch]
		%
		\subsubsection*{Initialisierungs-Zustand}
			Während der Initialisierung werden 4 wesentliche Schritte durchgeführt, die folgt kurz erläutert werden. Die Funktion des Zustandes an sich ist in Abschnitt \vref{ss:struktur} beschrieben. Da die unterschiedlichen Schritt zwingend sequentiell Ablaufen müssen, erfolgt die Umsetzung innerhalb Flat Sequence. Bei dieser \gls{g:labview}-Struktur wird eine folgende Sequenz erst abgearbeitet, wenn bei der aktuellen alle Knoten ausgeführt wurden. Weiter ist der Ablauf für ein Daten-Segment ausgelegt. Durch dies werden alle Operation auf dieselben Daten angewandt, was die Konsistenz des Ergebnisses erhöht. Eine Übersicht über den Initialisierungs-Zustand bietet die Abbildung \vref{img:init_phase}.
			%
			\image{content/4_implementierung/image/init_phase}{scale=.7}{htbp}[Initialisierungs-Zustand][img:init_phase]
			%
			\begin{enumerate}
				\item Filterung \texttt{Filter.vi}: Die \gls{ac:vi} wird grösstenteils aus dem Beispiel \textsf{ Posture Estimation} übernommen. Lediglich die zuvor eingesetzten Elliptischen Filter werden durch solche mit einer Butterworth-Charakteristik ersetzt und die Parameter an denen des in Abschnitt XXX beschrieben angepasst. 
				%
				\item Rotationsmatrix \texttt{Mrot.vi}: Für die Schätzung der Rotationswinkel und der Berechnung der Rotationsmatrix wird eine eigene \gls{ac:vi} angelehnt an bestehende realisiert. Wesentliche ist die Schätzung der Winkel, die mit der Gleichung XXX erfolgt und das folgende ermitteln der Matrix. Diese beiden \gls{ac:vi}s wurden übernommen und durch den konstanten Gravitätsvektor (dient als Bezugsachse für die Winkelschätzung) erweitert. Die wird in der Abbildung \vref{img:mrot} gezeigt.
					%
					\image{content/4_implementierung/image/mrot}{scale=.7}{htbp}[Rotationsmatrix][img:mrot]
				%
				\item Rotation \texttt{Rot.vi}: Die für Samples ausgelegte Rotation benötigt für Ihre Funktion die bei Schritt 2 erklärte Rotationsmatrix. Die eigentliche Rotation erfolgt mit einer Matrixmultiplikation, wobei die Beschleunigungsdaten zuvor in den benötigten Vektor umgewandelt werden müssen. Nach der Rotation werden die einzelnen Achsen aus dem Array extrahiert und nach \unitfrac{m}{s\high{2}} konvertiert\footnote{Die Messung der Beschleunigungsdaten erfolgt in g, was \unitfrac[9.81]{m}{s\high{2}} entspricht}. Der gesamte Datenfluss ist in der Abbildung \vref{img:rot} visualisiert.
					%
					\image{content/4_implementierung/image/rot}{scale=.7}{htbp}[Rotation][img:rot]
				%
				\item Standardabweichung: Für die Bestimmung der Standardabweichung für die spätere Bewegungsdetektion wird das aufgezeichnete Daten-Segment der \gls{ac:vi} \texttt{Std Deviation and Variance.vi} übergeben, die bereits Bestandteil von \gls{g:labview} ist.
			\end{enumerate}
		%
		%
		\subsubsection*{Signalverarbeitungs-Zustand}
			Die Signalverarbeitung erfolgt, wie in Abschnitt \vref{ss:struktur} genau beschrieben, mit Samples. Sie umfasst ebenfalls 4 Schritte, für deren korrekte Funktionalität eine Initialisierung benötigen wird (erfolgt durch ein Wechsel in den Initialisierungs-Zustand). Die erforderlichen Daten des vorherigen Zustandes werden durch Schieberegister übertragen. Die Abbildung \vref{img:sig_phase} zeigt den vollständigen Zustand, inklusive den Schieberegistern (orange, horizontale Linien).
			%
			\image{content/4_implementierung/image/progress_phase}{scale=.7}{htbp}[Signalverarbeitungs-Zustand][img:sig_phase]
			%
			\begin{enumerate}
				\item Filterung \texttt{Filter.vi}: Für das herausfiltern des Quantisierungsrauschens und anderen hochfrequenten Signale wird ein Tiefpass eingesetzt. Dazu wird dieselbe \gls{ac:vi} verwendet wie zuvor bei der Initialisierung (\gls{ac:iir}-Filter mit Butterworth Charakteristik).
				%
				\item Rotation \texttt{Rot.vi}: Erfolgt analog mit derselben \gls{ac:vi} wie im Initialisierungs-Zustand. Die benötigte Rotationsmatrix wird vom vorherigen Zustand durch ein Schieberegister übernommen. 
				%
				\item Integration \texttt{Inta.vi}
					%
					\image{content/4_implementierung/image/inta}{scale=.7}{htbp}[Integration][img:inta]
				%
				\item Netwerk-Stream
			\end{enumerate}
		%
		%
		\subsubsection*{Frontpanel}
			%
			\image{content/4_implementierung/image/front_myrio}{scale=1}{htbp}[Frontpanel \gls{g:myrio}][img:front_myrio]
		
	%
	%
	\subsection{Host}
		\subsubsection*{Visualisierung}
			%
			\image{content/4_implementierung/image/net_end_host}{scale=.7}{htbp}[Daten Empfangen][img:rx_data]
			%
			\begin{enumerate}
				\item Daten Extraktion
				\item Translation
				\item x-y-Graph
					%
					\image{content/4_implementierung/image/graph_chart_host}{scale=.7}{htbp}[Graph zu Chart][img:graph]
			\end{enumerate}
		%
		%
		\subsubsection*{Frontpanel}
			%
			\image{content/4_implementierung/image/front_host}{scale=.7}{htbp}[Frontpanel Host][img:front_host]
%
%
% Bedienung
\section{Bedienung}
%
\section{Validierung}