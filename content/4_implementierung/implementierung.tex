%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Titel:   Implementierung
% Autor:   zursr1, gross10
% Datum:   28.05.2014
% Version: 0.0.1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%:::Change-Log:::
% Versionierung erfolgt auf folgende Gegebenheiten: -1. Release Versionen
%                                                   -2. Neue Kapitel
%                                                   -3. Fehlerkorrekturen
%
% 0.0.0       Erstellung der Datei
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementierung}\label{ch:implementierung}
%
%
% Analyse Portierung MATLAB 
\section{Analyse Portierung MATLAB}\label{s:analyse_portierung_matlab}
	Für die Implementierung des im vorherigen Kapitels \vref{ch:konzept} konzeptionierten Algorithmus muss das erstellte \gls{g:matlab}-Skript analysiert werden. Es gilt \gls{ac:vi}s zu finden, die möglichst die gleiche Funktion haben wie die verwendeten Befehle und Toolboxen in \gls{g:matlab}. Dabei wird auf das Verwenden von \gls{g:matlab}-Skripten innerhalb von \gls{g:labview} verzichtet um die Eigenständigkeit der Implementierung zu gewährleisten\footnote{Mit der \gls{g:matlab}-Node ist es möglich \gls{g:matlab}-Code auszuführen, jedoch nicht auf einem Real-Time System wie das \gls{g:myrio} eines ist. Ausserdem muss für das Ausführen lokal \gls{g:matlab} installiert sein \cite{lit:labview_matlab}.}. Weiter soll eine Struktur gefunden werden, die den Ablauf des \gls{g:matlab}-Skripts widerspiegelt.
	%
	\subsection{Struktur}\label{ss:struktur}
		Betrachtet man die Abbildung \vref{img:blockdiagramm} im Abschnitt \ref{s:blockdiagramm}, so sind zwei Bereiche offensichtlich. Der erste Teil beinhaltet das Schätzen der Rotationswinkel mit Hilfe der Gravität und das anschliessende berechnen der Rotationsmatrix. Darauf folgt das Anwenden der Rotationsmatrix auf die gemessenen Daten und das Integrieren, was der zweite Teil des Konzepts darstellt. Die beiden Teile lassen sich in ein Zustandsdiagramm transformieren, das es erlaubt die Implementierung zu strukturieren. Das Diagramm ist dargestellt in der Abbildung \vref{img:statediagramm}. \gls{g:labview} bietet einige Möglichkeiten den Datenfluss durch Strukturen zu beeinflussen. Für eine Zustandsmaschine bietet sich die Case Structure an, die äquivalent zu dem Konstrukt switch-case der Programmiersprache C funktioniert. 
		%
		\image{content/4_implementierung/image/zustandsdiagramm}{scale=.8}{htbp}[Zustandswechsel][img:statediagramm]
		%
		\subsubsection*{Initialisierungs-Zustand}
			Der erste Zustand stellt die Initialisierung dar. Er wird aufgerufen wenn der Taster am \gls{g:myrio} gedrückt wird. Wie im Konzept vorgesehen werden die Rotationswinkel geschätzt und die Rotationsmatrix bestimmt. Dies geschieht über eine einstellbare Anzahl von Samples. Anzumerken ist, dass während der Aufzeichnung dieser Samples das \gls{g:myrio} nicht berührt werden darf\footnote{Verfälscht die Schätzung der Winkel, was eine inkorrekte Matrix zur Folge hat.}. Im Unterschied zum Konzept wird ausserdem die Standardabweichung der aufgezeichneten Daten bestimmt. Diese wird im Zustand Signalverarbeitung für die Bewegungsdetektion verwendet\footnote{Im Konzept wird dies während der Signalverarbeitung durchgeführt, da Segment basierend.}. 
		%
		\subsubsection*{Signalverarbeitungs-Zustand}
			Im zweiten Zustand erfolgt wie vorgesehen die Signalverarbeitung bestehend aus den Teilen Rotieren, Bewegungsdetektion und Integrieren. Für korrekte Ergebnisse muss zuvor eine Initialisation durchgeführt worden sein. Im Gegensatz zum Konzept und dem vorherigen Zustand erfolgt die Verarbeitung Sample basierend. So kann eine schnelle Laufzeit und ein geringerer Speicherverbrauch forciert, jedoch nicht garantiert werden. Zusätzlich zum Konzept muss noch eine Möglichkeit bestehen die verarbeiteten Daten aus dem Target zu extrahieren. Dazu muss, wie in Abschnitt \vref{ss:myRIO_hw} beschrieben, ein Netzwerkstream zum Host aufgebaut werden. 
	%
	\subsection{Tiefpass-Filterung}
		\gls{g:labview} bietet eine Vielzahl von Möglichkeiten Filter einzusetzen. Sie unterscheiden sich hauptsächlich durch ihre Charakteristik und Implementierung. Bezüglich der Umsetzung existieren Segment und Sample basierte \gls{ac:vi}s. Da die Signalverarbeitung mit Samples arbeitet, kann ein Tiefpassfilter der \texttt{NI\_PtByPt} Bibliothek eingesetzt werden\footnote{\gls{ac:vi} Bezeichnung \texttt{Butterworth Filter PtByPt.vi}}. Die Charakteristik ist wie im Konzept Butterworth (\acrshort{ac:iir}-Filter).
	%
	\subsection{Schätzung der Orientierung}
		Die Schätzung der Orientierung erfolgt analog zum Konzept. Dazu muss eine eigene \gls{ac:vi} basierend auf bestehenden erstellt werden. Die Implementierung ist im Abschnitt \vref{ss:demo_target} erklärt.
	%
	\subsection{Rotation}
		Wie zuvor die Schätzung der Orientierung existiert keine vorgefertigte \gls{ac:vi} für diese Aufgabe. Die Implementierung muss mit Hilfe von bestehenden Komponenten erfolgen, wobei sich diese auf mathematische Operationen beschränken.
	%
	\subsection{Bewegungsdetektion}
		Wie im Abschnitt \vref{ss:struktur} angetönt erfolgt die Bewegungsdetektion in zwei Schritten. Im ersten werden die Schwellen für eine ruhende Position des \gls{g:myrio} ermittelt. Diese dienen bei der Signalverarbeitung als Vergleichswert, was das Erkennen einer Bewegung ermöglicht. Begründet durch diese Aufteilung kann dieser Vorgang nicht einem einzelnen \gls{ac:vi} erfolgen, sondern muss durch einzelne vorhandene Komponenten umgesetzt werden.	
	%
	\subsection{Integration}\label{ss:implementierung_int}
		Für die zweifache Integration werden \acrshort{ac:iir}-Filter eingesetzt die durch eine bilineare Transformation eines Integrators bestimmt wurden. \gls{g:labview} bietet eine \gls{ac:vi} Namens \texttt{IIR Cascade Filter PtByPt.vi}, die es erlaubt direkt die Filterkoeffizienten anzugeben. Die Implementierung ist dabei wie in Gleichung \vref{eq:irr_filter} dargestellt. Zu beachten ist, dass die Koeffizienten nicht vertauscht werden, da die Angabe in der Reihenfolge Nenner $a_x$ Zähler $b_x$ erfolgt.
		%
		\formula{
		H(z)=\frac{b_0+b_1\cdot z^{-1}+\cdots+b_{N_b-1}\cdot z^{-(N_b-1)}}{1+a_1\cdot z^{-1}+\cdots+a_{N_a-1}\cdot z^{-(N_a-1)}}
		}{
		b_x & Forward Koeffizienten\\
		a_x & Reverse Koeffizienten\\
		N_b & Anzahl Forward Koeffizienten\\
		N_a & Anzahl Reverse Koeffizienten\\
		}[eq:irr_filter]
%
%
% Demonstrator
\section{Demonstrator}\label{s:demonstrator}
	Der Demonstrator stellt die Umsetzung des zuvor analysierten \gls{g:matlab}-Skripts dar. Er dient hauptsächlich zur Demonstration des entwickelten Algorithmus, soll aber auch dessen Funktionalität auf einer embedded Hardware zeigen. Die Implementierung basiert auf dem Beispielprojekt \textsf{Posture Estimation} von \gls{ac:ni}, das der Installation von \gls{g:labview} beiliegt. Die Daten der folgend beschriebenen Umsetzung (Projekt \texttt{reametric}) sind im Anhang \vref{s:anhang_labview} zu finden.\par 
	%
	%
	\subsection{Target}\label{ss:demo_target}
		Das \gls{g:labview}-Projekt ist in zwei Teile gegliedert. Der eine beinhaltet \gls{ac:vi}s die auf dem Target ausgeführt werden (\texttt{RT Main.vi}) und der andere diejenigen des Hosts \texttt{Desktop Main.vi}. Dieser Umstand ist im Abschnitt \vref{ss:aufbau_struktur} näher erläutert. Für die Ausführung auf seitens des Targets werden die erstellten \gls{ac:vi}s einem Kompilationsprozess unterzogen, der für das Target ausführbaren Code erzeugt. Im Falle des \gls{g:myrio} wird dies Code für die beiden ARM-Cores und das FPGA sein. Diese Aussage kann jedoch mangels Transparenz des Prozesses nicht bewiesen werden ist nur eine Annahme.
		%
		\subsubsection*{Zustandsmaschine}
			Die Zustandsmaschine wird mit Hilfe einer Case Structure umgesetzt, wie bereits im Abschnitt \vref{ss:struktur} angetönt. Für den Wechsel zwischen den beiden Vorhanden Zuständen dient ein Taster als Auslöser eines entsprechenden Events. Um die Bedienung komfortabel zu gestalten kann auf zwei Möglichkeiten eine Initialisierung ausgelöst werden.
			%
			\begin{itemize}
				\item \textbf{Hardware Taster} Für die eine Reinitialisierung direkt beim Messaufbau kann der Taster \textsf{Button0} am Gehäuse des \gls{g:myrio} betätigt werden.
				\item \textbf{Software Taster} Erfolgt die Bedienung von Messaufbau entfernt via des Host, so bietet die \textit{RT Main}-\gls{ac:vi} einen entsprechenden Taster.
			\end{itemize}
			%
			Implementiert wird diese Funktion zum einen mit einer speziellen \gls{ac:vi} des \gls{g:myrio} für das Abfragen des Tasters und zum anderen mit einer \gls{ac:vi} für die Flankenerkennung (\texttt{Edge Detect.vi}). Der Software Taster wird mit diesem Aufbau durch ein ODER-Gatter verknüpft. Die Abbildung \vref{img:state_switch} zeigt das gesamte Konstrukt.
			%
			\image{content/4_implementierung/image/button}{scale=.7}{htbp}[Zustandswechsel][img:state_switch]
		%
		\subsubsection*{Initialisierungs-Zustand}
			Während der Initialisierung werden 4 wesentliche Schritte durchgeführt, die folgt kurz erläutert werden. Die Funktion des Zustandes an sich ist in Abschnitt \vref{ss:struktur} beschrieben. Da die unterschiedlichen Schritte zwingend sequentiell Ablaufen müssen, erfolgt die Umsetzung innerhalb Flat Sequence. Bei dieser \gls{g:labview}-Struktur wird eine folgende Sequenz erst abgearbeitet, wenn bei der aktuellen alle Knoten ausgeführt wurden. Weiter ist der Ablauf für ein Daten-Segment ausgelegt. Durch dies werden alle Operation auf dieselben Daten angewandt, was die Konsistenz des Ergebnisses erhöht. Eine Übersicht über den Initialisierungs-Zustand bietet die Abbildung \vref{img:init_phase}.
			%
			\image{content/4_implementierung/image/init_phase}{scale=.7}{htbp}[Initialisierungs-Zustand][img:init_phase]
			%
			\begin{enumerate}
				\item Filterung \texttt{Filter.vi}: Die \gls{ac:vi} wird grösstenteils aus dem Beispiel \textsf{ Posture Estimation} übernommen. Lediglich die zuvor eingesetzten Elliptischen Filter werden durch solche mit einer Butterworth-Charakteristik ersetzt und die Parameter an denen des in Abschnitt XXX beschrieben angepasst. 
				%
				\item Rotationsmatrix \texttt{Mrot.vi}: Für die Schätzung der Rotationswinkel und der Berechnung der Rotationsmatrix wird eine eigene \gls{ac:vi} angelehnt an bestehende realisiert. Wesentliche ist die Schätzung der Winkel, die mit der Gleichung XXX erfolgt und das folgende ermitteln der Matrix. Diese beiden \gls{ac:vi}s wurden übernommen und durch den konstanten Gravitätsvektor (dient als Bezugsachse für die Winkelschätzung) erweitert. Die Umsetzung wird in der Abbildung \vref{img:mrot} gezeigt.
					%
					\image{content/4_implementierung/image/mrot}{scale=.7}{htbp}[Rotationsmatrix][img:mrot]
				%
				\item Rotation \texttt{Rot.vi}: Die für Samples ausgelegte Rotation benötigt für Ihre Funktion die bei Schritt 2 erklärte Rotationsmatrix. Die eigentliche Rotation erfolgt mit einer Matrixmultiplikation, wobei die Beschleunigungsdaten zuvor in den benötigten Vektor umgewandelt werden müssen. Nach der Rotation werden die einzelnen Achsen aus dem Array extrahiert und nach \unitfrac{m}{s\high{2}} konvertiert\footnote{Die Messung der Beschleunigungsdaten erfolgt in g, was \unitfrac[9.81]{m}{s\high{2}} entspricht}. Der gesamte Datenfluss ist in der Abbildung \vref{img:rot} visualisiert.
					%
					\image{content/4_implementierung/image/rot}{scale=.7}{htbp}[Rotation][img:rot]
				%
				\item Standardabweichung: Für die Bestimmung der Standardabweichung für die spätere Bewegungsdetektion wird das aufgezeichnete Daten-Segment der \gls{ac:vi} \texttt{Std Deviation and Variance.vi} übergeben, die bereits Bestandteil von \gls{g:labview} ist.
			\end{enumerate}
		%
		%
		\subsubsection*{Signalverarbeitungs-Zustand}
			Die Signalverarbeitung erfolgt, wie in Abschnitt \vref{ss:struktur} genau beschrieben, mit Samples. Sie umfasst ebenfalls 4 Schritte, für deren korrekte Funktionalität eine Initialisierung benötigen wird (erfolgt durch ein Wechsel in den Initialisierungs-Zustand). Die erforderlichen Daten des vorherigen Zustandes werden durch Schieberegister übertragen. Die Abbildung \vref{img:sig_phase} zeigt den vollständigen Zustand, inklusive den Schieberegistern (orange, horizontale Linien).
			%
			\image{content/4_implementierung/image/progress_phase}{scale=.7}{htbp}[Signalverarbeitungs-Zustand][img:sig_phase]
			%
			\begin{enumerate}
				\item Filterung \texttt{Filter.vi}: Für das herausfiltern des Quantisierungsrauschens und anderen hochfrequenten Signale wird ein Tiefpass eingesetzt. Dazu wird dieselbe \gls{ac:vi} verwendet wie zuvor bei der Initialisierung (\gls{ac:iir}-Filter mit Butterworth Charakteristik).
				%
				\item Rotation \texttt{Rot.vi}: Erfolgt analog mit derselben \gls{ac:vi} wie im Initialisierungs-Zustand. Die benötigte Rotationsmatrix wird vom vorherigen Zustand durch ein Schieberegister übernommen. 
				%
				\item Integration \texttt{Inta.vi}: Für die Wegbestimmung muss die Beschleunigung zweifach integriert werden. Zuvor erfolgt noch eine Auswertung der aktuellen Standardabweichung (ermittelt mit der \gls{ac:vi} \texttt{Standard Deviation PtByPt.vi}), die mit der Standardabweichung des während des Initialisierungs-Zustand aufgenommenen Segments verglichen wird. Fällt sie höher aus, kann von einer Bewegung ausgegangen werden. Die folgende Integration wird, wie zuvor in Abschnitt \vref{ss:implementierung_int} beschrieben, durch jeweils zwei \acrshort{ac:iir}-Filter bewerkstelligt. Speziell zu beachten ist, dass im Falle der ruhenden Position (keine Bewegung detektiert) der zurückgelegte Weg gleich wohl angezeigt werden muss. Für dieses Verhalten wird eine Feedback Node \gls{ac:vi} eingesetzt.
					%
					\image{content/4_implementierung/image/inta}{scale=.7}{htbp}[Integration][img:inta]
				%
				\item Netwerk-Stream: Der Netzwerk-Stream wird dazu verwendet die verarbeiteten Daten an den Host zu übertragen. Die Grundlagen dazu sind im Abschnitt \vref{ss:myRIO_hw} unter Daten extrahieren erläutert. Die Daten, die für eine Darstellung der Ergebnisse auf den Host benötigt werden, beschränken sich auf die x-y-Koordinaten.
			\end{enumerate}
		%
		%
		\subsubsection*{Frontpanel}
			Mit dem Frontpanel kann die \texttt{RT Main.vi} und die darunter liegenden \gls{ac:vi}s gesteuert werden. Die möglichen Einstellungen beschränken sich auf ein Minimum. Müssen tiefgreifendere Anpassungen vorgenommen werden\footnote{z.B. Anpassung der Abtastfrequenz}, muss die in den jeweiligen \gls{ac:vi}s erfolgen. \par
			%
			Der Aufbau des Frontpanels kann der Abbildung \vref{img:front_myrio} entnommen werden. Die einzelnen Elemente werden folgt kurz erklärt.
			\begin{enumerate}
				\item Der Taster \textsf{Init} dient zum Auslösen einer Reinitialisierung. Beschrieben ist dieser Vorgang im Abschnitt \vref{ss:demo_target} unter Zustandsmaschine.
				\item Durch den Indikator \textsf{Init} wird die Initialisierungs-Phase visualisiert (leuchtet grün).
				\item Die Dauer, respektive die Anzahl Samples die für die Bestimmung der Rotationsmatrix im Initialisierungs-Zustand verwendet werden kann zwischen 1000 und 5000 eingestellt werden. Mit der aktuell eingestellten Abtastrate von \unit[1]{kHz} entspricht diese Angabe ebenfalls der benötigten zeit in \unit{ms}.
				\item Die Schaltfläche \textsf{stop} dient zum Beenden der laufenden \gls{ac:vi}. Durch dessen Betätigung wird ebenfalls, nachdem verstreichen eines Timeouts, die \gls{ac:vi} des Host abgebrochen (Netwerk-Stream Fehler). 
				\item Sollen die Elemente zur Wegbestimmung auf ihre Standardwerte zurückgestellt werden, so kann die Schaltfläche \textsf{initalize} gedrückt werden.
				\item Konnte erfolgreich eine Netzwerkverbindung zum Host hergestellt werden, wird dies durch den Indikator \textsf{connected?} dargestellt.
			\end{enumerate}
			%
			\image{content/4_implementierung/image/front_myrio}{scale=1.5}{htbp}[Frontpanel \gls{g:myrio}][img:front_myrio]	
	%
	%
	\subsection{Host}\label{ss:host}
		Der Host Teil des Demonstrators dient lediglich der Darstellung der auf dem Target verarbeiteten Daten. In der Projektstruktur ist die \gls{ac:vi} des Hosts unter dem Namen \texttt{Desktop Main.vi} zu finden. Die Ausführung erfolgt direkt in \gls{g:labview}, sprich es wird keine Kompilation durchgeführt\footnote{Diese Aussage beruht auf eigens gemachte Beobachtungen der Autoren und kann bewiesen werden}.
		%
		\subsubsection*{Visualisierung}
			Die Darstellung der übertragenen Daten erfolgt sample-basiert. Dazu müssen die Daten zuerst extrahiert und anschliessend ansprechend dargestellt werden. Weite Teile dieses \gls{ac:vi} wurden aus dem Beispielprojekt übernommen, wie auch die Abbildung \vref{img:rx_data} zeigt. Die Darstellung erfolgt durch ein 3D-Modell des \gls{g:myrio} und einem Pfadverlauf in einem x-y-Graph.
			%
			\image{content/4_implementierung/image/net_end_host}{scale=.7}{htbp}[Daten Empfangen][img:rx_data]
			%
			\begin{enumerate}
				\item Daten Extraktion: Aus der übertragenen Datenstruktur werden die x- und y-Koordina\-ten mit Hilfe der \texttt{Read Single Element from Stream.vi} extrahiert . Diese Aufteilung in die einzelnen Komponenten ist für eine Darstellung in der x-y-Ebene Voraussetzung. 
				%
				\item Translation: Um die Translation des \gls{g:myrio} im Raum darzustellen, muss auf das vorhandene 3D-Modell die \texttt{Set Translation.vi} angewandt werden.
				\item x-y-Graph \texttt{XY-Graph as Chart.vi}: Die \texttt{XY Graph.vi} kann Daten nur aus einem bestehenden Segment darstellen. Da die Koordinaten jedoch sample-weise kontinuierlich übertragen werden, muss ein Buffer implementiert werden. Dieser muss zusätzlich die Charakteristik eines Schieberegisters aufweisen, das, wenn der Buffer überläuft, die ältesten Daten verwirft. Mit einer solchen \gls{ac:vi} kann anschliessend eine Konvertierung des Graphs in eine Chart erfolgen. Ein entsprechende Umsetzung kann in \cite{lit:labview_graph_as_chart} gefunden werden. Dargestellt ist sie in der Abbildung \vref{img:graph}.
					%
					\image{content/4_implementierung/image/graph_chart_host}{scale=.7}{htbp}[Graph zu Chart][img:graph]
			\end{enumerate}
		%
		%
		\subsubsection*{Frontpanel}
			Das Frontpanel der \texttt{Desktop Main.vi} dient hauptsächlich der Visualisierung der empfangenen Daten. Daneben bietet es auch noch grundlegende Bedienungsmöglichkeiten.\par 
			%
			Die Abbildung \vref{img:front_host} zeigt das gesamte Panel. Auf die vorhanden Elemente wird folgt nun eingegangen.
			\begin{enumerate}
				\item Im Texteingabefeld \textsf{myRIO IP-Address} muss die aktuelle IP-Adresse des \gls{g:myrio} angegeben werden. Diese kann je nach Netzwerkkonfiguration unterschiedlich ausfallen muss jeweils kurz kontrolliert werden.
				\item Konnte eine Verbindung zum Target aufgebaut werden, so wird dies durch ein grünes Leuchten des Indikators \textsf{connected?} kundgetan. 
				\item Darstellung des 3D-Modells im dreidimensionalen Raum.
				\item Zurückgelegter Pfad in der x-y-Ebene. Die Auflösung der Achsen wird dabei laufend angepasst und ist unbedingt zu beachten.
				\item Die Schaltfläche \textsf{stop} dient zum Beenden der laufenden \gls{ac:vi}. Dies hat ebenfalls eine Unterbrechung der Netzwerkverbindung zur Folge.
				\item Mit dem Taster \textsf{reset graph} kann, wie der Name schon andeutet, der Graph gelöscht werden. 
				\item Die beiden Text-Labels \textsf{x} und \textsf{y} zeigen die aktuelle Position an.
			\end{enumerate}
			%
			\image{content/4_implementierung/image/front_host}{scale=.7}{htbp}[Frontpanel Host][img:front_host]
%
%
% Bedienung
\section{Bedienung}
	Für einen erfolgreichen Betrieb des Demonstrators sind einige Dinge zu beachten. Falls einer der folgt aufgeführten Schritte nicht funktioniert, sollte zuerst die Verbindung zum \gls{g:myrio} überprüft werden. Dies beinhaltet ebenfalls den aktuelle Zustand des Treibers\footnote{Während der Implementationsphase kam es zu diversen Abstürzen. Durch einen Neustart des Host konnte dieses Problem jedoch jedes mal behoben werden}.\par
	%
	Die gesamte Bedienung umfasst insgesamt XXX Schritte.
	\begin{enumerate}
		\item Das \gls{g:myrio} mit dem Host-System verbinden.
		\item \gls{g:labview} starten und das Projekt \texttt{reametric} öffnen (ist im Anhang \vref{s:anhang_labview} zu finden).
		\item Starten der \texttt{RT Main.vi}. Konnte ein Verbindung zum Target hergestellt werden, wird der Kompilationsprozess ohne Probleme beendet werden. Ist dies nicht der Fall, so müssen die Schritte 1 und 2 wiederholt werden.
		\item Abschliessend folgt der Start der \texttt{Desktop Main.vi}. Konnte eine Verbindung zur \texttt{RT Main.vi} aufgebaut werden, so wird dies durch Indikatoren visualisiert (siehe Abschnitt \vref{ss:demo_target} und \vref{ss:host}, Frontpanel).
		\item Für korrekte Ergebnisse muss zu Beginn eine Initialisierung durchgeführt werden. Dies erfolgt durch entsprechende Bedienelemente am \gls{g:myrio} oder der \texttt{RT Main.vi} (siehe Abschnitt \vref{ss:demo_target}, Frontpanel).
		\item Die Messung wird beendet durch das Betätigen der Schaltflächen \textsf{stop} in den jeweiligen \gls{ac:vi}s. Die Ausführung sollte nicht einfach direkt abgebrochen werden, da ansonsten das Target sich einem undefinierten Zustand befinden kann\footnote{\gls{g:labview} präsentiert entsprechende Fehlermeldungen}.
	\end{enumerate}
%
\section{Validierung}