%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Titel:   Implementierung
% Autor:   zursr1, gross10
% Datum:   28.05.2014
% Version: 0.0.1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%:::Change-Log:::
% Versionierung erfolgt auf folgende Gegebenheiten: -1. Release Versionen
%                                                   -2. Neue Kapitel
%                                                   -3. Fehlerkorrekturen
%
% 0.0.0       Erstellung der Datei
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementierung}\label{ch:implementierung}
%
%
% Analyse Portierung MATLAB 
\section{Analyse Portierung MATLAB}\label{s:analyse_portierung_matlab}
	Für die Implementierung des im vorherigen Kapitel \vref{ch:konzept} konzipierten Algorithmus muss das erstellte \gls{g:matlab}-Skript analysiert werden. Es gilt \gls{ac:vi} zu finden, die möglichst die gleiche Funktion haben wie die verwendeten Befehle und Toolboxen in \gls{g:matlab}. Dabei wird auf das Verwenden von \gls{g:matlab}-Skripten innerhalb von \gls{g:labview} verzichtet, um die Eigenständigkeit der Implementierung zu gewährleisten\footnote{Mit der \gls{g:matlab}-Node ist es möglich \gls{g:matlab}-Code auszuführen, jedoch nicht auf einem Real-Time System wie das \gls{g:myrio} eines ist. Ausserdem muss für das Ausführen lokal \gls{g:matlab} installiert sein \cite{lit:labview_matlab}.}. Weiter soll eine Struktur gefunden werden, die den Ablauf des \gls{g:matlab}-Skripts widerspiegelt.
	%
	\subsection{Struktur}\label{ss:struktur}
		Betrachtet man die Abbildung \vref{img:blockdiagramm} im Abschnitt \ref{s:blockdiagramm}, so sind zwei Bereiche offensichtlich. Der erste Teil beinhaltet das Schätzen der Rotationswinkel mithilfe der Gravitation und das anschliessende Berechnen der Rotationsmatrix. Darauf folgt das Anwenden der Rotationsmatrix auf die gemessenen Daten und das Integrieren, was den zweite Teil des Konzepts darstellt. Die beiden Teile lassen sich in ein Zustandsdiagramm transformieren, das es erlaubt, die Implementierung zu strukturieren. Das Diagramm ist dargestellt in der Abbildung \vref{img:statediagramm}. \gls{g:labview} bietet einige Möglichkeiten, den Datenfluss durch Strukturen zu beeinflussen. Für eine Zustandsmaschine bietet sich die \texttt{Case Structure} an, die äquivalent zu dem Konstrukt \texttt{switch-case} der Programmiersprache C funktioniert. 
		%
		\image{content/4_implementierung/image/zustandsdiagramm}{scale=.8}{htbp}[Zustandswechsel][img:statediagramm]
		%
		\subsubsection*{Kalibrations-Zustand}
			Der erste Zustand stellt die Kalibration dar. Er wird aufgerufen, wenn der Taster am \gls{g:myrio} gedrückt wird. Wie im Konzept vorgesehen, werden die Rotationswinkel geschätzt und die Rotationsmatrix bestimmt. Dies geschieht über eine einstellbare Anzahl von Samples. Anzumerken ist, dass während der Aufzeichnung dieser Samples das \gls{g:myrio} nicht berührt werden darf\footnote{Verfälscht die Schätzung der Winkel, was eine inkorrekte Matrix zur Folge hat.}. Im Unterschied zum Konzept wird ausserdem die Standardabweichung der aufgezeichneten Daten bestimmt. Diese wird im Zustand \textsf{Bewegung} für die Bewegungsdetektion verwendet\footnote{Im Konzept wird dies während der Signalverarbeitung durchgeführt, da Segment basierend.}. 
		%
		\subsubsection*{Bewegungs-Zustand}
			Im zweiten Zustand erfolgt wie vorgesehen die Signalverarbeitung, bestehend aus den Teilen Rotieren, Bewegungsdetektion und Integrieren. Für korrekte Ergebnisse muss zuvor eine Kalibration durchgeführt werden. Im Gegensatz zum Konzept und dem vorherigen Zustand erfolgt die Verarbeitung Sample-basiert. So kann eine schnelle Laufzeit und ein geringerer Speicherverbrauch forciert, jedoch nicht garantiert werden. Zusätzlich zum Konzept muss noch eine Möglichkeit bestehen, die verarbeiteten Daten aus dem \gls{g:target} zu extrahieren. Dazu muss, wie in Abschnitt \vref{ss:myRIO_hw} beschrieben, ein Netzwerkstream zum \gls{g:host} aufgebaut werden. 
	%
	\subsection{Tiefpass-Filterung}
		\gls{g:labview} bietet eine Vielzahl von Möglichkeiten, Filter einzusetzen. Sie unterscheiden sich hauptsächlich durch ihre Charakteristik und Implementierung. Bezüglich der Umsetzung existieren Segment-basierte und Sample-basierte \gls{ac:vi}. Da die Signalverarbeitung mit Samples arbeitet, kann ein Tiefpassfilter der \texttt{NI\_PtByPt}-Bibliothek eingesetzt werden\footnote{Die \gls{ac:vi} Bezeichnung ist \texttt{Butterworth Filter PtByPt.vi}.}. Die Charakteristik ist wie im Konzept ein Butterworth (\acrshort{ac:iir}-Filter).
	%
	\subsection{Schätzung der Orientierung}
		Die Schätzung der Orientierung erfolgt analog zum Konzept. Dazu muss eine eigene \gls{ac:vi} basierend auf bestehenden erstellt werden. Die Implementierung ist im Abschnitt \vref{ss:demo_target} erklärt.
	%
	\subsection{Rotation}
		Wie zuvor die Schätzung der Orientierung existiert keine vorgefertigte \gls{ac:vi} für diese Aufgabe. Die Implementierung muss mithilfe von bestehenden Komponenten erfolgen, wobei sich diese auf mathematische Operationen beschränken.
	%
	\subsection{Bewegungsdetektion}
		Wie im Abschnitt \vref{ss:struktur} angetönt erfolgt die Bewegungsdetektion in zwei Schritten. Im ersten werden die Schwellen für eine ruhende Position des \gls{g:myrio} ermittelt. Diese dienen bei der Signalverarbeitung als Vergleichswert, was das Erkennen einer Bewegung ermöglicht. Begründet durch diese Aufteilung, kann dieser Vorgang nicht in einem einzelnen \gls{ac:vi} erfolgen, sondern muss durch einzelne vorhandene Komponenten umgesetzt werden.	
	%
	\subsection{Berechnung der Bewegung}\label{ss:implementierung_int}
		Für die zweifache Integration werden \acrshort{ac:iir}-Filter eingesetzt, die durch eine Bilineare-Trans\-for\-ma\-ti\-on eines Integrators bestimmt werden. \gls{g:labview} bietet eine \gls{ac:vi} namens \texttt{Discrete Zero-Pole-Gain.vi}, die es erlaubt, direkt die Filterkoeffizienten anzugeben. Die Implementierung ist  in Gleichung \vref{eq:irr_filter} dargestellt. Zu beachten ist, dass für die Darstellung, im Gegensatz zur Gleichung \vref{eq:int_filter} im Konzept, die Pol-Nullstellen-Form verwendet wird.
		%
		\formula{
		&H(z)=k\cdot\frac{(z-Z_1)(z-Z_2)\ldots (z-Z_m)}{(z-P_1)(z-P_2)\ldots (z-P_n)}\\[2ex]
		&\Longrightarrow H(z)=\frac{T_a}{2}\cdot\frac{z+1}{z-1}
		}{
		k & Verstärkungsfaktor\\
		Z_x & Nullstellen\\
		P_x & Polstellen\\
		T_a & Abtastfrequenz\\
		}[eq:irr_filter]
%
%
% Demonstrator
\section{Demonstrator}\label{s:demonstrator}
	Der Demonstrator stellt die Umsetzung des zuvor analysierten \gls{g:matlab}-Skripts dar. Er dient hauptsächlich zur Demonstration des entwickelten Algorithmus, soll aber auch dessen Funktionalität auf einer embedded Hardware zeigen. Die Implementierung basiert auf dem Beispielprojekt \textsf{Posture Estimation} von \gls{ac:ni}, das der Installation von \gls{g:labview} beiliegt. Die Daten der im folgenden beschriebenen Umsetzung (Projekt \texttt{reametric}) sind im Anhang \vref{s:anhang_labview} zu finden.\par 
	%
	%
	\subsection{Target}\label{ss:demo_target}
		Das \gls{g:labview}-Projekt ist in zwei Teile gegliedert. Der eine Teil beinhaltet \gls{ac:vi} die auf dem \gls{g:target} ausgeführt werden (\texttt{RT Main.vi}) und der andere Teil diejenigen des \gls{g:host}s \texttt{Desktop Main.vi}. Dieser Umstand ist im Abschnitt \vref{ss:aufbau_struktur} näher erläutert. Für die Ausführung aufseiten des \gls{g:target} werden die erstellten \gls{ac:vi} einem Kompilationsprozess unterzogen, der einen für das \gls{g:target} ausführbaren Code erzeugt. Im Falle des \gls{g:myrio} wird dieser Code für die beiden ARM-Cores und das \acrshort{ac:fpga} sein. Diese Aussage kann jedoch mangels Transparenz des Prozesses nicht bewiesen werden und ist nur eine Annahme.
		%
		\subsubsection*{Zustandsmaschine}
			Die Zustandsmaschine wird mithilfe einer \texttt{Case Structure} umgesetzt, wie bereits im Abschnitt \vref{ss:struktur} erläutert. Für den Wechsel zwischen den beiden vorhandenen Zuständen dient ein Taster als Auslöser eines entsprechenden Events. Um die Bedienung komfortabel zu gestalten, kann eine Kalibration auf zwei Arten  ausgelöst werden.
			%
			\begin{itemize}
				\item \textbf{Hardware Taster} Für eine Reinitialisierung beim Messaufbau kann der Taster \textsf{Button0} am Gehäuse des \gls{g:myrio} betätigt werden.
				\item \textbf{Software Taster} Erfolgt die Bedienung entfernt vom Messaufbau via \gls{g:host}, so bietet die \texttt{RT Main}-\gls{ac:vi} einen entsprechenden Taster.
			\end{itemize}
			%
			Implementiert wird diese Funktion zum einen mit einer speziellen \gls{ac:vi} des \gls{g:myrio} für das Abfragen des Tasters und zum anderen mit einer \gls{ac:vi} für die Flankenerkennung (\texttt{Edge Detect.vi}). Der Software Taster wird mit diesem Aufbau durch ein ODER-Gatter verknüpft. Die Abbildung \vref{img:state_switch} zeigt das gesamte Konstrukt.
			%
			\image{content/4_implementierung/image/button}{scale=.7}{htbp}[Zustandswechsel][img:state_switch]
		%
		\subsubsection*{Kalibration-Zustand}
			Während der Kalibrierung werden 4 wesentliche Schritte durchgeführt, die im folgenden kurz erläutert werden. Die Funktion des Zustandes an sich ist in Abschnitt \vref{ss:struktur} beschrieben. Da die unterschiedlichen Schritte zwingend sequenziell Ablaufen müssen, erfolgt die Umsetzung innerhalb \texttt{Flat Sequence}. Bei dieser \gls{g:labview}-Struktur wird eine folgende Sequenz erst abgearbeitet, wenn bei der aktuellen alle Knoten ausgeführt sind. Weiter ist der Ablauf für ein Daten-Segment ausgelegt. Dadurch werden alle Operationen auf dieselben Daten angewendet, was die Konsistenz des Ergebnisses erhöht. Eine Übersicht über den Initialisierungs-Zustand bietet die Abbildung \vref{img:init_phase}.
			%
			\image{content/4_implementierung/image/init_phase}{scale=.7}{htbp}[Initialisierungs-Zustand][img:init_phase]
			%
			\begin{enumerate}
				\item Filterung \texttt{Filter.vi}: Die \gls{ac:vi} wird grösstenteils aus dem Beispiel \textsf{ Posture Estimation} übernommen. Lediglich die zuvor eingesetzten elliptischen Filter werden durch solche mit einer Butterworth-Charakteristik ersetzt und die Parameter, an die in Abschnitt \vref{ss:tp} beschriebenen angepasst. 
				%
				\item Rotationsmatrix \texttt{Mrot.vi}: Für die Schätzung der Rotationswinkel und der Berechnung der Rotationsmatrix wird eine eigene \gls{ac:vi}, angelehnt an bestehende, realisiert. Wesentlich ist die Schätzung der Winkel, die mit der Gleichung \vref{subsec:orientierungsschätzung} erfolgt, und das darauf folgende Ermitteln der Matrix. Diese beiden \gls{ac:vi} werden übernommen und durch den konstanten Gravitationsvektor (dient als Bezugsachse für die Winkelschätzung) erweitert. Die Umsetzung wird in der Abbildung \vref{img:mrot} gezeigt.
					%
					\image{content/4_implementierung/image/mrot}{scale=.7}{htbp}[Rotationsmatrix][img:mrot]
				%
				\item Rotation \texttt{Rot.vi}: Die für die Samples ausgelegte Rotation benötigt für ihre Funktion die bei Schritt 2 erklärte Rotationsmatrix. Die eigentliche Rotation erfolgt mit einer Matrixmultiplikation, wobei die Beschleunigungsdaten zuvor in den benötigten Vektor umgewandelt werden müssen. Nach der Rotation werden die einzelnen Achsen aus dem Array extrahiert und nach \unitfrac{m}{s\high{2}} konvertiert\footnote{Die Messung der Beschleunigungsdaten erfolgt in g, was \unitfrac[9.81]{m}{s\high{2}} entspricht}. Der gesamte Datenfluss ist in Abbildung \vref{img:rot} visualisiert.
					%
					\image{content/4_implementierung/image/rot}{scale=.7}{htbp}[Rotation][img:rot]
				%
				\item Standardabweichung: Für die Bestimmung der Standardabweichung für die spätere Bewegungsdetektion wird das aufgezeichnete Daten-Segment der \gls{ac:vi} \texttt{Std Deviation and Variance.vi} übergeben, die bereits Bestandteil von \gls{g:labview} ist.
			\end{enumerate}
		%
		%
		\subsubsection*{Bewegungs-Zustand}
			Die Signalverarbeitung erfolgt, wie in Abschnitt \vref{ss:struktur} genau beschrieben, Sample-basiert. Sie umfasst 3 Schritte, für deren korrekte Funktionalität eine Initialisierung benötigt wird (erfolgt durch einen Wechsel in den \textsf{Initialisierungs-Zustand}). Die erforderlichen Daten des vorherigen Zustandes werden durch Schieberegister übertragen. Die Abbildung \vref{img:sig_phase} zeigt den vollständigen Zustand, inklusive Schieberegister (orange, horizontale Linien).
			%
			\image{content/4_implementierung/image/progress_phase}{scale=.68}{htbp}[Signalverarbeitungs-Zustand][img:sig_phase]
			%
			\begin{enumerate}
				\item Rotation \texttt{Rot.vi}: Erfolgt analog mit derselben \gls{ac:vi} wie im \textsf{Initialisierungs-Zustand}. Die benötigte Rotationsmatrix wird vom vorherigen Zustand durch ein Schieberegister übernommen. 
				%
				\item Integration \texttt{Inta.vi}: Für die Wegbestimmung muss die Beschleunigung zweifach integriert werden. Zuvor erfolgt noch eine Auswertung der aktuellen Standardabweichung (ermittelt mit der \gls{ac:vi} \texttt{Standard Deviation PtByPt.vi}), die mit der Standardabweichung des während des \textsf{Initialisierungs-Zustandes} aufgenommenen Segments verglichen wird. Fällt sie höher aus, kann von einer Bewegung ausgegangen werden. Die folgende Integration wird, wie zuvor in Abschnitt \vref{ss:implementierung_int} beschrieben, durch jeweils zwei \acrshort{ac:iir}-Filter bewerkstelligt. Speziell zu beachten ist, dass im Falle der ruhenden Position (keine Bewegung detektiert) der zurückgelegte Weg gleichwohl angezeigt werden muss. Für dieses Verhalten wird eine \textsf{Feedback Node} \gls{ac:vi} eingesetzt. Der gesamte Aufbau ist in der Abbildung \vref{img:inta} dargestellt.
					%
					\image{content/4_implementierung/image/inta}{scale=.7}{htbp}[Integration][img:inta]
				%
				\item Netwerk-Stream: Der Netzwerk-Stream wird dazu verwendet, die verarbeiteten Daten an den \gls{g:host} zu übertragen. Die Grundlagen dazu sind im Abschnitt \vref{ss:myRIO_hw} unter \textsf{Daten extrahieren} erläutert. Die Daten, die für eine Darstellung der Ergebnisse im \gls{g:host} benötigt werden, beschränken sich auf die x-y-Koordinaten.
			\end{enumerate}
		%
		%
		\subsubsection*{Frontpanel}
			Mit dem Frontpanel können die \texttt{RT Main.vi} und die darunter liegenden \gls{ac:vi} gesteuert werden. Die möglichen Einstellungen beschränken sich auf ein Minimum. Müssen tiefergreifende Anpassungen vorgenommen werden\footnote{Z.B. die Anpassung der Abtastfrequenz.}, muss dies in den jeweiligen \gls{ac:vi} erfolgen. \par
			%
			Der Aufbau des Frontpanels kann der Abbildung \vref{img:front_myrio} entnommen werden. Die einzelnen Elemente werden im folgenden kurz erklärt.
			\begin{enumerate}
				\item Der Taster \textsf{Init} dient zum Auslösen einer Reinitialisierung. Beschrieben ist dieser Vorgang im Abschnitt \vref{ss:demo_target} unter \textsf{Zustandsmaschine}.
				\item Durch den Indikator \textsf{Init} wird die \textsf{Kalibrations-Phase} visualisiert (leuchtet grün).
				\item Die Dauer, respektive die Anzahl Samples, die für die Bestimmung der Rotationsmatrix im \textsf{Initialisierungs-Zustand} verwendet werden, kann zwischen 1'000 und 5'000 eingestellt werden. Mit der aktuell eingestellten Abtastrate von \unit[1]{kHz} entspricht diese Angabe ebenfalls der benötigten Zeit in \unit{ms}.
				\item Die Schaltfläche \textsf{stop} dient zum Beenden der laufenden \gls{ac:vi}. Durch deren Betätigung wird ebenfalls, nach dem Verstreichen eines Time-outs, die \gls{ac:vi} des \gls{g:host} abgebrochen (Netwerkstream Fehler). 
				\item Sollen die Elemente zur Wegbestimmung auf ihre Standardwerte zurückgestellt werden, so kann die Schaltfläche \textsf{initialize} gedrückt werden.
				\item Konnte erfolgreich eine Netzwerkverbindung zum \gls{g:host} hergestellt werden, wird dies durch den Indikator \textsf{connected?} dargestellt.
			\end{enumerate}
			%
			\image{content/4_implementierung/image/front_myrio}{scale=1.5}{htbp}[Frontpanel \gls{g:myrio}][img:front_myrio]	
	%
	%
	\subsection{Host}\label{ss:host}
		Der \gls{g:host}-Teil des Demonstrators dient lediglich der Darstellung der auf dem \gls{g:target} verarbeiteten Daten. In der Projektstruktur ist die \gls{ac:vi} des \gls{g:host} unter dem Namen \texttt{Desktop Main.vi} zu finden. Die Ausführung erfolgt direkt in \gls{g:labview}; es wird keine Kompilation durchgeführt\footnote{Diese Aussage beruht auf eigens gemachten Beobachtungen der Autoren und kann nicht bewiesen werden.}.
		%
		\subsubsection*{Visualisierung}
			Die Darstellung der übertragenen Daten erfolgt Sample-basiert. Dazu müssen die Daten zuerst extrahiert und anschliessend dargestellt werden. Weite Teile dieses \gls{ac:vi} werden aus dem Beispielprojekt übernommen, wie auch die Abbildung \vref{img:rx_data} zeigt. Die Darstellung erfolgt durch ein 3-D-Modell des \gls{g:myrio} und einen Pfadverlauf in einem x-y-Graph.
			%
			\image{content/4_implementierung/image/net_end_host}{scale=.7}{htbp}[Daten empfangen][img:rx_data]
			%
			\begin{enumerate}
				\item Daten-Extraktion: Aus der übertragenen Datenstruktur werden die x- und y-Koordina\-ten mithilfe der \texttt{Read Single Element from Stream.vi} extrahiert. Diese Aufteilung in die einzelnen Komponenten ist für eine Darstellung in der x-y-Ebene Voraussetzung. 
				%
				\item Translation: Um die Translation des \gls{g:myrio} im Raum darzustellen, muss auf das vorhandene 3-D-Modell das \texttt{Set Translation.vi} angewendet werden.
				\item x-y-Graph \texttt{XY-Graph as Chart.vi}: Das \texttt{XY Graph.vi} kann Daten nur aus einem bestehenden Segment darstellen. Da die Koordinaten jedoch Sample-weise kontinuierlich übertragen werden, muss ein Buffer implementiert werden. Dieser muss zusätzlich die Charakteristik eines Schieberegisters aufweisen, das, wenn der Buffer überläuft, die ältesten Daten verwirft. Mit einer solchen \gls{ac:vi} kann anschliessend eine Konvertierung des Graphs in einen Chart erfolgen. Eine entsprechende Umsetzung kann in \cite{lit:labview_graph_as_chart} gefunden werden. Dargestellt ist sie in der Abbildung \vref{img:graph}.
					%
					\image{content/4_implementierung/image/graph_chart_host}{scale=.7}{htbp}[Graph zu Chart][img:graph]
			\end{enumerate}
		%
		%
		\subsubsection*{Frontpanel}
			Das Frontpanel der \texttt{Desktop Main.vi} dient hauptsächlich der Visualisierung der empfangenen Daten. Daneben bietet es auch noch grundlegende Bedienungsmöglichkeiten.\par 
			%
			Die Abbildung \vref{img:front_host} zeigt das gesamte Panel. Auf die vorhandenen Elemente wird nun eingegangen.
			\begin{enumerate}
				\item Im Texteingabefeld \textsf{myRIO IP-Address} muss die aktuelle IP-Adresse des \gls{g:myrio} angegeben werden. Diese kann je nach Netzwerkkonfiguration unterschiedlich ausfallen und muss jeweils kurz kontrolliert werden.
				\item Konnte eine Verbindung zum \gls{g:target} aufgebaut werden, so wird dies durch ein grünes Leuchten des Indikators \textsf{connected?} kundgetan. 
				\item Darstellung des 3-D-Modells im dreidimensionalen Raum.
				\item Zurückgelegter Pfad in der x-y-Ebene. Die Auflösung der Achsen wird dabei laufend angepasst und ist unbedingt zu beachten.
				\item Die Schaltfläche \textsf{stop} dient zum Beenden der laufenden \gls{ac:vi}. Dies hat ebenfalls eine Unterbrechung der Netzwerkverbindung zur Folge.
				\item Mit dem Taster \textsf{reset graph} kann, wie der Name schon andeutet, der Graph gelöscht werden. 
				\item Die beiden Text-Labels \textsf{x} und \textsf{y} zeigen die aktuelle Position an.
			\end{enumerate}
			%
			\image{content/4_implementierung/image/front_host}{scale=.7}{t}[Frontpanel \gls{g:host}][img:front_host]
%
%
% Bedienung
\section{Bedienung}
	Für einen erfolgreichen Betrieb des Demonstrators sind einige Dinge zu beachten. Falls einer der nachstehend aufgeführten Schritte nicht funktioniert, sollte zuerst die Verbindung zum \gls{g:myrio} überprüft werden. Dies beinhaltet ebenfalls den aktuellen Zustand des Treibers\footnote{Während der Implementationsphase kam es zu diversen Abstürzen. Durch einen Neustart des \gls{g:host} konnte dieses Problem jedoch jedes Mal behoben werden.}.\par
	%
	Die gesamte Bedienung umfasst insgesamt 6 Schritte.
	\begin{enumerate}
		\item Das \gls{g:myrio} mit dem \gls{g:host}-System verbinden.
		\item \gls{g:labview} starten und das Projekt \texttt{reametric} öffnen (siehe Anhang \vref{s:anhang_labview}).
		\item Starten des \texttt{RT Main.vi}. Kann eine Verbindung zum \gls{g:target} hergestellt werden, wird der \textsf{Kompilationsprozess} ohne Probleme beendet werden. Ist dies nicht der Fall, so müssen die Schritte 1 und 2 wiederholt werden.
		\item Abschliessend folgt der Start des \texttt{Desktop Main.vi}. Kann eine Verbindung zum \texttt{RT Main.vi} aufgebaut werden, so wird dies durch Indikatoren visualisiert (siehe Abschnitt \vref{ss:demo_target} und \vref{ss:host}, Frontpanel).
		\item Für korrekte Ergebnisse muss zu Beginn eine Initialisierung durchgeführt werden. Dies erfolgt durch entsprechende Bedienelemente am \gls{g:myrio} oder dem \texttt{RT Main.vi} (siehe Abschnitt \vref{ss:demo_target}, Frontpanel).
		\item Die Messung wird beendet durch das Betätigen der Schaltflächen \textsf{stop} in den jeweiligen \gls{ac:vi}. Die Ausführung sollte nicht einfach direkt abgebrochen werden, da sich ansonsten das \gls{g:target} in einem undefinierten Zustand befinden kann\footnote{\gls{g:labview} präsentiert eine entsprechende Fehlermeldung.}.
	\end{enumerate}
%
\section{Vergleich Konzept - Implementierung}
	Um eine Aussage bezüglich der Güte der Implementierung machen zu können, muss diese mit dem Konzept verglichen werden. Dazu müssen identische Rohdaten durch die beiden Abläufe (\gls{g:matlab}-Skript \texttt{Check\_Translation\_Rotation\_final.m} und \gls{g:labview}-Projekt \texttt{reametric}) verarbeitet und die Ergebnisse einander gegenübergestellt werden\footnote{Durch die Tatsache, dass das \gls{g:matlab}-Skript Segment-basiert und die Implementierung Sample-basiert arbeiten, können nicht dieselben Daten verwendet werden - Dies hätte eine Änderung der Implementierung oder des Konzepts zur Folge. Deshalb werden zwei unabhängige Messungen unter den identischen Bedingungen durchgeführt und ausgewertet.}. Angelehnt an die drei Protokolle in den Abschnitten \ref{s:verifikation_rotation} bis \ref{s:verifikation_transaltion_rotation} werden dabei speziell \textsf{Rotation}, \textsf{Translation} und \textsf{Rotation, Translation überlagert} kontrolliert\footnote{Aufgrund der negativen Ergebnisse der Protokolle wird auf ein detailliertes Wiederholen verzichtet und die Implementierung im Ansatz überprüft.}.
	%
	\subsection*{Schätzung Rotationswinkel und Rotation}
		Für das Überprüfen der Rotationswinkel und der anschliessenden Rotation wird eine statische Messung in z-Position (erläutert in Abschnitt \vref{ss:methode_tran}, Testbeschreibung) durchgeführt. Die Kontrolle beschränkt sich auf das Endergebnis der Rotation, das $a_{Soll}=[0\quad0\quad 9.81]^\top$ sein sollte.\par
		%
		Wie erwartet liefert das Konzept ein ähnliches Resultat von $a_{Kon.} = [-0.004\quad0.004\quad9.971]^\top$. Unter den gleichen Bedingungen errechnet die Implementierung einen Beschleunigungsvektor von $a_{Impl.}=[0.008\quad0.013\quad9.934]^\top$. Vergleicht man die beiden Resultate, kann man auf eine korrekte Implementierung des Konzepts schliessen. Die geringen Abweichungen könnten darin begründet sein, dass die Auflösung der verwendeten Datentypen sich in \gls{g:matlab} und \gls{g:labview} unterscheiden. 
	%	
	\subsubsection*{Translation}
		Wiederum werden zwei Messungen in der z-Position durchgeführt. Zusätzlich zu der \textsf{Kalibrationsphase} wird nun noch eine Translation in der \gls{g:transversalebene} von \unit[5.0]{cm} in y-Richtung durchgeführt (Bewegungszeit \unit[1.0]{s}). Erwartet wird ein zurückgelegter Weg von \unit[5.0]{cm} (mit einer Abweichung von $\pm$\unit[1.0]{cm}) in der gefahrenen Richtung.\par
		%
		Gemittelt über fünf Messungen ergibt das Konzept ein äquivalentes Resultat, wie im Protokoll in Abschnitt \vref{s:verifikation_translation} beschrieben. Die ermittelte Strecke beläuft sich auf \unit[4.31]{cm}. Die Implementierung dagegen liefert ein um Faktor 1'000 kleineres Resultat. Dazu wird die Auslenkung nur in eine Richtung detektiert. Eine Translation zurück zum Ursprung der Messung hat demzufolge eine entgegengesetzte Bewegung zur Folge. Die Unterscheidung hinsichtlich der gefahrenen Achse x und y wird dagegen korrekt erkannt.\par
		%
		Die Analyse des ungenügenden Resultats kann auf eine fehlerhafte Integration durch die \gls{ac:iir}-Filter zurückgeführt werden. Simulationen mit bekannten Signalen kräftigen die Vermutung, dass der Fehler mit der Abtastrate der Beschleunigungsdaten zusammenhängt. Folgende Untersuchungen müssen dies jedoch noch bestätigen.
	%
	\subsubsection*{Rotation, Translation überlagert}
		Wegen des negativen Resultats des Protokolls in Abschnitt \vref{s:verifikation_transaltion_rotation} und dem bekannten fehlerbehafteten Integrieren der Implementation	wird auf eine genauere Untersuchung dieses Testfalls verzichtet. Konzeptbedingt ist dazu kein aussagekräftiger Vergleich zu erwarten.		