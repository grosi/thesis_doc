%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Titel:   Grundlagen
% Autor:   zursr1, gross10
% Datum:   28.05.2014
% Version: 0.0.1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%:::Change-Log:::
% Versionierung erfolgt auf folgende Gegebenheiten: -1. Release Versionen
%                                                   -2. Neue Kapitel
%                                                   -3. Fehlerkorrekturen
%
% 0.0.0       Erstellung der Datei
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Grundlagen}\label{ch:grundlagen}
%
%
%Anatomie des Knies
\section{Anatomie des Knies}
%
%
%LabVIEW auf NI myRIO
\section{LabVIEW auf NI myRIO}
	In der Konzept- und Implementationsphase\footnote{für detaillierte Erläuterungen zu den Projektphasen sei auf den Abschnitt \vref{ss:ablauf_gliederung_projekt} verwiesen} wird das Werkzeug \gls{g:labview} der Firma \gls{ac:ni} verwendet. \gls{g:labview} ist die Abkürzung für \textsf{Laboratory Virtual Instrument Engineering Workbench} und stellt eine Entwicklungsumgebung und eine grafische Programmiersprache dar. Es wurde in den 70er Jahren von den Mitgründer von \gls{ac:ni}, Jim Truchard und Jeff Kodosky entworfen und wird stetig weiter entwickelt. Im Gegensatz zu den gängigen Hochsprachen wie C/C++ sind in \gls{g:labview} der Datenfluss im Zentrum und nicht Kontrollstrukturen, soll heissen das Datenflussprinzip wird verfolgt \cite[19-22]{lit:labview}.
	%
	\subsection{Aufbau und Struktur}
		Ein \gls{g:labview}-Projekt besteht aus mindestens einem \gls{ac:vi}, indem sich Funktionsblöcke oder weitere \gls{ac:vi}s befinden können. Eine \gls{ac:vi} stellt sich zusammen aus einem Frontpanel und einem Blockdiagramm zusammen. Das Frontpanel stellt dabei die Benutzeroberfläche dar, dagegen das Blockdiagramm die eigentliche Funktionalität beinhaltet.\par
		%
		Ein wichtiger Aspekt im Aufbau eines \gls{g:labview}-Projekts ist die Unterscheidung zwischen dem Host und dem Target. Der Host bezeichnet dabei der Computer mit installiertem \gls{g:labview} und das Target ein zu \gls{g:labview} kompatible embedded Hardware, z.B. eine Datenerfassungskarte. Daten die auf dem Target erfasst werden, befinden sich trotz bestehender Kommunikation zum Host nicht automatisch auf demselben. Sie werden stattdessen auf dem internen Speicher des Targets gespeichert und müssen anschliessen aus diesem Speicher extrahiert werden\footnote{dieses Fallbeispiel bezieht sich auf die Hardware \gls{g:myrio}}. Ebenso wird zwischen \gls{ac:vi}s auf dem Host und Target unterschieden. Sie müssen für beide Systeme separat gestartet werden. Die Aufteilung ist im Projektdialog durch eine unterschiedliche Dateibaumtiefe visualisiert, wie der Abbildung \vref{img:labview_gliederung} zu entnehmen ist.
		%
		\image{content/2_grundlagen/image/labview_gliederung}{scale=0.7}{htbp}[\gls{g:labview}-Gliederung][img:labview_gliederung]
	%
	\subsection{Hardware}\label{ss:myRIO_hw}
		Für die Datenerfassung wird das \gls{g:myrio} eingesetzt. Es handelt sich dabei um ein günstiges Developmentboard für den raschen Einstieg in \gls{g:labview}. Es bietet folgende für das Projekt notwendige Spezifikationen\footnote{nähere Angaben sind im Datenblatt im Anhang \vref{ch:datasheet_myrio} zu finden}:
		\begin{itemize}
			\item Prozessor/FPGA Xilinx Z-7010 (Cortex A9), 2 Kerne à \unit[667]{MHz}
			\item \unit[256]{MB} Flash, \unit[512]{MB} RAM
			\item USB 2.0 Hi-Speed
			\item Accelerometer, 3 Achsen, $\pm$\unit[8]{g}, \unit[12]{bit} Auflösung
		\end{itemize}
		%
		Die gesamte Hardware, inklusive Beschleunigungssensor ist in einem kompakten Gehäuse verbaut, wie die Abbildung \vref{img:myrio} zeigt. Die Befestigung kann auf einfache weise mit Hilfe von drei Schrauben erfolgen.
		%
		\image{content/2_grundlagen/image/myrio}{scale=0.2}{htbp}[\gls{g:myrio} \cite{img:myrio}][\gls{g:myrio}][img:myrio]
		%
		\subsubsection*{Bedienung}
			Das \gls{g:myrio} benutzt als Betriebssystem ein Real Time Linux von \gls{ac:ni}. Dies bietet dem Nutzer eine Vielzahl von Möglichkeiten das \gls{g:myrio} zu bedienen \cite{lit:rt_linux}.
			%
			\begin{description}
				\item[\gls{g:labview}] Normalerweise erfolgt die Bedienung via \gls{g:labview}. Dabei werden \gls{ac:vi}s erstellt und auf das \gls{g:myrio} geladen. Zusätzlich besteht die Möglichkeit mit Hilfe vorgefertigter \gls{ac:vi}s direkt auf Real Time Linux zuzugreifen.
				%
				\item[NI MAX]
				%
				\item[Weboberfläche]
				%
				\item[Terminal]
			\end{description}
		%
		\paragraph*{Daten extrahieren}
	%
	\subsection{Unterscheidung Host und Target}
%
%
%DAQ in MATLAB
\section{\acrshort{ac:daq} in \gls{g:matlab}}
	\gls{g:matlab} bietet zum direkten Auslesen von Daten eine Data Acquisition Toolbox an. In dieser können angeschlossene \acrshort{ac:daq}-Karten in einer sogenannten Session direkt in \gls{g:matlab} Beispielsweise mittels USB ausgelesen werden. Auch können Daten/Signale, welche in \gls{g:matlab} generiert wurden über Ausgänge der Karte ausgegeben werden.\par 
	%
	Zum Auslesen eines Beschleunigungssensors wurde ein kurzes \gls{g:matlab}-Skript geschrieben (ersichtlich in \vref{ch:daqauslesen}). Dieses Skript sollte auch zukünftigen Arbeiten eine schnelle und einfache Verwendung der Beschleunigungssensoren ermöglichen.
%
%
%Rotationsmatrix
\section{Rotationsmatrix}
In der Linearen Algebra bietet eine Rotationsmatrix die Möglichkeit, einen Punkt im Raum um einen bestimmten Winkel $\phi$ zu drehen. In unserem Fall ist eine Rotation eines Punktes um eine Gerade im Raum nötig. Dies wurde in der Linearen Algebra mit Herrn Jenni im zweiten Semester behandelt \cite{lit:linalg2}.\par
%
Wir möchten den Punkt P mit den Koordinaten $\left(x\mid y\mid z\right)$ um den Winkel $\phi$ im Gegenuhrzeigersinn um die Gerade g in den Punkt P' mit Koordinaten $\left(x'\mid y'\mid z'\right)$ drehen. Die Gerade g hat dabei die Richtung $\overrightarrow{n}=\left(a\;b\;c\right)^{T}$ und verläuft durch den Ursprung. Ihre Parameterdarstellung ist somit: $\overrightarrow{r}= \lambda*\overrightarrow{n}$ mit $\lambda\;\epsilon\;\mathbb{R}$.\par
%
\image{content/2_grundlagen/image/rotmat}{scale=0.6}{htbp}[Drehung des Punktes P in P' \cite{lit:linalg2}][Drehung des Punktes P in P'][img:rotmat]
%           
Die Rotationsmatrix ist wie schon erwähnt definiert durch den Drehwinkel $\phi$ und der Geraden g. In dieser Matrix wird wie in Abbildung \vref{img:rotmat} ersichtlich zuerst der Schnittpunkt S der Geraden g mit der Ebene E in welcher die Punkte P und P' liegen und welche Senkrecht auf die Gerade g steht berechnet. Anschliessend ist aus dem Schnittpunkt S und dem Ausgangspunkt P die Berechnung des gedrehten Punktes P' möglich. Die Berechnung des gedrehten Punktes P' mit der Rotationsmatrix lässt sich somit zusammenfassen in Gleichung \vref{eq:rot}:\par
%
%Berechnung des gedrehten Punkt P'
\formula{
            \left(\begin{array}{c}x'\\ y'\\z'\end{array}\right)=R_{g;O;\overrightarrow{n};\phi}*\left(\begin{array}{c}x\\ y\\z\end{array}\right)
        }{
            R_{g;O;\overrightarrow{n};\phi} & Rotationsmatrix mit Winkel $\phi$ um die Gerade g}[eq:rot]\par
%
Auf die Zusammensetzung der Rotationsmatrix soll nicht weiter eingegangen werden. Sie beinhaltet die oben genannten Rechnungsschritte. Zur Anwendung genügt der Aufbau der Matrix zu kennen, welcher in Gleichung \vref{eq:rotmax} ersichtlich ist:\par  
%
% Aufbau der Rotationsmatrix
\formula{
            R_{g;O;\overrightarrow{n};\phi} &= \cos(\phi)*\begin{bmatrix}1 & 0 & 0 \\0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}+\frac{(1-\cos(\phi))}{a^{2}+b^{2}+c^{2}}*\begin{bmatrix}a^{2} & ab & ac \\ ab & b^{2} & bc \\ ac & bc & c^{2} \end{bmatrix}\\&+\frac{\sin(\phi)}{\sqrt{a^{2}+b^{2}+c^{2}}}*\begin{bmatrix}0 & -c & b \\ c & 0 & -a \\ -b & a & 0 \end{bmatrix}
        }{ 
           }[eq:rotmax]
%
% nummerische Integration          
\section{nummerische Integration}
\subsection{Trapezmethode}
\subsection{Filter}